<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>高機能メモ帳アプリ</title>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Lucide Icons for UI icons -->
    <script src="https://unpkg.com/lucide-react@0.292.0/dist/lucide-react.js"></script>
    
    <!-- Google API Client Library -->
    <script src="https://apis.google.com/js/api.js"></script>

    <style>
        /* Custom styles for the editor and overall look */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc; /* slate-50 */
        }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        
        /* Hide scrollbar but allow scrolling */
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        /* Style for the contenteditable editor */
        #editor {
            min-height: 400px;
            outline: none;
            border: 1px solid #e2e8f0; /* slate-200 */
            padding: 1rem;
            border-radius: 0.5rem;
            line-height: 1.6;
        }
        #editor:focus {
            border-color: #3b82f6; /* blue-500 */
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }
        
        /* Animation for modals */
        .modal-enter {
            opacity: 0;
            transform: scale(0.95);
        }
        .modal-enter-active {
            opacity: 1;
            transform: scale(1);
            transition: opacity 300ms, transform 300ms;
        }
        .modal-exit {
            opacity: 1;
            transform: scale(1);
        }
        .modal-exit-active {
            opacity: 0;
            transform: scale(0.95);
            transition: opacity 300ms, transform 300ms;
        }
    </style>
</head>
<body class="text-slate-800">

    <div id="app" class="max-w-4xl mx-auto p-4 md:p-6">
        
        <!-- Header Section -->
        <header class="flex justify-between items-center mb-6 pb-4 border-b border-slate-200">
            <h1 class="text-3xl font-bold text-slate-900 flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-notebook-tabs mr-3 text-blue-600"><path d="M2 6h4"/><path d="M2 10h4"/><path d="M2 14h4"/><path d="M2 18h4"/><rect width="16" height="20" x="4" y="2" rx="2"/><path d="M15 2v20"/><path d="M15 7h5"/><path d="M15 12h5"/><path d="M15 17h5"/></svg>
                メモ帳アプリ
            </h1>
            <div>
                <!-- Google Drive Authentication Buttons -->
                <button id="authorize_button" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-sm transition-all duration-200">Google Driveにサインイン</button>
                <button id="signout_button" class="hidden bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg shadow-sm transition-all duration-200">サインアウト</button>
            </div>
        </header>

        <!-- Main Content Area -->
        <main>
            <!-- Home View: List of notes and folders -->
            <div id="home-view">
                <div class="flex flex-col sm:flex-row justify-between items-center mb-4 gap-4">
                    <div id="breadcrumb" class="text-lg font-medium text-slate-600"></div>
                    <div class="flex items-center gap-2">
                        <div class="relative">
                            <select id="sort-select" class="appearance-none bg-white border border-slate-300 rounded-md py-2 pl-3 pr-8 text-sm leading-5 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                                <option value="createdAt_desc">作成日順（新しい順）</option>
                                <option value="createdAt_asc">作成日順（古い順）</option>
                                <option value="title_asc">名前順（昇順）</option>
                                <option value="title_desc">名前順（降順）</option>
                            </select>
                            <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-slate-700">
                                <svg class="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg>
                            </div>
                        </div>
                        <button id="create-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg flex items-center gap-2 shadow-sm transition-all duration-200">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-plus"><path d="M5 12h14"/><path d="M12 5v14"/></svg>
                            <span>作成</span>
                        </button>
                    </div>
                </div>
                <div id="items-list" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                    <!-- Items will be dynamically inserted here -->
                </div>
                 <div id="empty-state" class="hidden text-center py-16">
                    <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-file-plus-2 mx-auto text-slate-400 mb-4"><path d="M4 22h14a2 2 0 0 0 2-2V7.5L14.5 2H6a2 2 0 0 0-2 2v4"/><polyline points="14 2 14 8 20 8"/><path d="M3 15h6"/><path d="M6 12v6"/></svg>
                    <p class="text-slate-500">アイテムがありません。</p>
                    <p class="text-slate-500 text-sm mt-1">「作成」ボタンから新しいメモやフォルダを追加しましょう。</p>
                </div>
            </div>

            <!-- Editor View -->
            <div id="editor-view" class="hidden">
                <div class="flex justify-between items-center mb-4">
                    <button id="back-to-home" class="bg-slate-200 hover:bg-slate-300 text-slate-800 font-bold py-2 px-4 rounded-lg flex items-center gap-2 transition-all duration-200">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-left"><path d="m12 19-7-7 7-7"/><path d="M19 12H5"/></svg>
                        戻る
                    </button>
                    <div id="sync-status" class="text-sm text-slate-500"></div>
                </div>
                <input type="text" id="note-title" placeholder="タイトルを入力..." class="text-3xl font-bold w-full p-2 mb-4 border-b-2 border-slate-200 focus:outline-none focus:border-blue-500 transition-colors">
                
                <!-- Editor Toolbar -->
                <div class="flex items-center gap-2 bg-slate-100 p-2 rounded-t-lg border border-b-0 border-slate-200">
                    <button class="editor-tool-btn" data-command="bold">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-bold"><path d="M14 12a4 4 0 0 0 0-8H6v8"/><path d="M15 20a4 4 0 0 0 0-8H6v8Z"/></svg>
                    </button>
                    <button class="editor-tool-btn" data-command="italic">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-italic"><line x1="19" x2="10" y1="4" y2="4"/><line x1="14" x2="5" y1="20" y2="20"/><line x1="15" x2="9" y1="4" y2="20"/></svg>
                    </button>
                    <div class="w-px h-6 bg-slate-300 mx-2"></div>
                    <button class="editor-tool-btn" data-command="undo">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-undo-2"><path d="M9 14 4 9l5-5"/><path d="M4 9h10.5a8.5 8.5 0 1 1-4.13 15.87"/></svg>
                    </button>
                    <button class="editor-tool-btn" data-command="redo">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-redo-2"><path d="M15 14 20 9l-5-5"/><path d="M20 9H9.5A8.5 8.5 0 1 0 13.6 21.8"/></svg>
                    </button>
                </div>
                
                <!-- The actual editor area -->
                <div id="editor" contenteditable="true"></div>
            </div>
        </main>
    </div>

    <!-- Create New Item Modal -->
    <div id="create-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-sm modal-enter">
            <h3 class="text-xl font-bold mb-6 text-center">新規作成</h3>
            <div class="flex justify-around">
                <button id="create-note-btn" class="flex flex-col items-center gap-3 p-4 rounded-lg hover:bg-slate-100 transition-colors w-32">
                    <svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-file-text text-blue-500"><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/><path d="M10 9H8"/><path d="M16 13H8"/><path d="M16 17H8"/></svg>
                    <span class="font-semibold">メモ</span>
                </button>
                <button id="create-folder-btn" class="flex flex-col items-center gap-3 p-4 rounded-lg hover:bg-slate-100 transition-colors w-32">
                    <svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-folder-plus text-yellow-500"><path d="M4 20h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.93a2 2 0 0 1-1.66-.9l-.82-1.2A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2Z"/><path d="M12 10v6"/><path d="M9 13h6"/></svg>
                    <span class="font-semibold">フォルダ</span>
                </button>
            </div>
            <button id="cancel-create-btn" class="mt-6 w-full bg-slate-200 hover:bg-slate-300 text-slate-800 font-bold py-2 px-4 rounded-lg transition-colors">キャンセル</button>
        </div>
    </div>
    
    <!-- Delete Confirmation Modal -->
    <div id="delete-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-sm modal-enter">
            <h3 class="text-xl font-bold mb-2 text-center">アイテムの削除</h3>
            <p class="text-slate-600 mb-6 text-center">本当に削除しますか？<br>この操作は取り消せません。</p>
            <div class="flex justify-center gap-4">
                <button id="cancel-delete-btn" class="bg-slate-200 hover:bg-slate-300 text-slate-800 font-bold py-2 px-4 rounded-lg transition-colors w-32">キャンセル</button>
                <button id="confirm-delete-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition-colors w-32">削除</button>
            </div>
        </div>
    </div>


    <script>
    document.addEventListener('DOMContentLoaded', () => {

        // --- Google Drive API Configuration ---
        // IMPORTANT: You need to create your own API Key and Client ID from Google Cloud Platform.
        // https://console.cloud.google.com/
        const API_KEY = 'YOUR_API_KEY'; // Replace with your API Key
        const CLIENT_ID = 'YOUR_CLIENT_ID'; // Replace with your Client ID
        const DISCOVERY_DOCS = ["https://www.googleapis.com/discovery/v1/apis/drive/v3/rest"];
        const SCOPES = 'https://www.googleapis.com/auth/drive.file';
        const APP_FILENAME = 'my-notepad-app-data.json';
        let driveFileId = null;

        // --- DOM Elements ---
        const homeView = document.getElementById('home-view');
        const editorView = document.getElementById('editor-view');
        const itemsList = document.getElementById('items-list');
        const createBtn = document.getElementById('create-btn');
        const backToHomeBtn = document.getElementById('back-to-home');
        const editor = document.getElementById('editor');
        const noteTitleInput = document.getElementById('note-title');
        const sortSelect = document.getElementById('sort-select');
        const breadcrumb = document.getElementById('breadcrumb');
        const emptyState = document.getElementById('empty-state');
        const syncStatus = document.getElementById('sync-status');
        
        // Modals
        const createModal = document.getElementById('create-modal');
        const createNoteBtn = document.getElementById('create-note-btn');
        const createFolderBtn = document.getElementById('create-folder-btn');
        const cancelCreateBtn = document.getElementById('cancel-create-btn');
        const deleteModal = document.getElementById('delete-modal');
        const cancelDeleteBtn = document.getElementById('cancel-delete-btn');
        const confirmDeleteBtn = document.getElementById('confirm-delete-btn');

        // Google Auth Buttons
        const authorizeButton = document.getElementById('authorize_button');
        const signoutButton = document.getElementById('signout_button');

        // --- Application State ---
        let state = {
            items: [],
            currentView: 'home', // 'home' or 'editor'
            currentParentId: null, // null for root, or folder ID
            editingItemId: null,
            sortBy: 'createdAt_desc',
            isGapiReady: false,
            isGsiReady: false,
            tokenClient: null,
            isSaving: false,
            deleteCandidateId: null,
        };
        
        let saveTimeout;

        // --- Utility Functions ---
        const generateUUID = () => crypto.randomUUID();

        // --- Data Persistence (Local & Google Drive) ---
        const saveData = async () => {
            localStorage.setItem('memoAppData', JSON.stringify(state.items));
            if (gapi.client.getToken() && driveFileId) {
                setSyncStatus('保存中...');
                try {
                    await saveToDrive();
                    setSyncStatus('Google Driveに保存済み');
                } catch (error) {
                    console.error('Error saving to Google Drive:', error);
                    setSyncStatus('Driveへの保存に失敗');
                }
            }
        };

        // --- Google Drive Functions ---
        const gapiLoaded = () => {
            gapi.load('client', initializeGapiClient);
        };

        const initializeGapiClient = async () => {
            await gapi.client.init({
                apiKey: API_KEY,
                discoveryDocs: DISCOVERY_DOCS,
            });
            state.isGapiReady = true;
            updateAuthButtons();

            // After GAPI is ready, check if user is already signed in.
            // If so, load data from Drive. This handles page reloads.
            if (gapi.client.getToken()) {
                await loadFromDrive();
            }
        };

        const gisLoaded = () => {
            state.tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: CLIENT_ID,
                scope: SCOPES,
                callback: '', // defined later
            });
            state.isGsiReady = true;
            updateAuthButtons();
        };

        const handleAuthClick = () => {
            if (API_KEY === 'YOUR_API_KEY' || CLIENT_ID === 'YOUR_CLIENT_ID') {
                alert('Google Drive連携機能を使用するには、コード内のAPI_KEYとCLIENT_IDを設定してください。');
                return;
            }
            state.tokenClient.callback = async (resp) => {
                if (resp.error !== undefined) {
                    throw (resp);
                }
                updateAuthButtons();
                await loadFromDrive(); // Sync after sign-in
            };

            if (gapi.client.getToken() === null) {
                state.tokenClient.requestAccessToken({ prompt: 'consent' });
            } else {
                state.tokenClient.requestAccessToken({ prompt: '' });
            }
        };

        const handleSignoutClick = () => {
            const token = gapi.client.getToken();
            if (token !== null) {
                google.accounts.oauth2.revoke(token.access_token);
                gapi.client.setToken('');
                driveFileId = null;
                updateAuthButtons();
                setSyncStatus('');
            }
        };

        const updateAuthButtons = () => {
            const token = gapi.client.getToken();
            if (token) {
                authorizeButton.style.display = 'none';
                signoutButton.style.display = 'block';
            } else {
                authorizeButton.style.display = 'block';
                signoutButton.style.display = 'none';
            }
        };

        const findOrCreateAppFile = async () => {
            try {
                const response = await gapi.client.drive.files.list({
                    q: `name='${APP_FILENAME}' and mimeType='application/json' and trashed=false`,
                    fields: 'files(id, name)',
                    spaces: 'drive',
                });
                if (response.result.files && response.result.files.length > 0) {
                    driveFileId = response.result.files[0].id;
                } else {
                    const createResponse = await gapi.client.drive.files.create({
                        resource: {
                            name: APP_FILENAME,
                            mimeType: 'application/json',
                        },
                        fields: 'id',
                    });
                    driveFileId = createResponse.result.id;
                    // Save current local data to the new file
                    await saveToDrive();
                }
            } catch (error) {
                console.error('Error finding or creating app file:', error);
            }
        };

        const saveToDrive = async () => {
            if (!driveFileId) return;
            const content = JSON.stringify(state.items);
            const boundary = '-------314159265358979323846';
            const delimiter = "\r\n--" + boundary + "\r\n";
            const close_delim = "\r\n--" + boundary + "--";

            const metadata = {
                'mimeType': 'application/json'
            };

            const multipartRequestBody =
                delimiter +
                'Content-Type: application/json\r\n\r\n' +
                JSON.stringify(metadata) +
                delimiter +
                'Content-Type: application/json\r\n\r\n' +
                content +
                close_delim;

            await gapi.client.request({
                path: `/upload/drive/v3/files/${driveFileId}`,
                method: 'PATCH',
                params: { uploadType: 'multipart' },
                headers: { 'Content-Type': 'multipart/related; boundary="' + boundary + '"' },
                body: multipartRequestBody,
            });
        };

        const loadFromDrive = async () => {
            await findOrCreateAppFile();
            if (!driveFileId) return;
            setSyncStatus('Google Driveから読込中...');
            try {
                const response = await gapi.client.drive.files.get({
                    fileId: driveFileId,
                    alt: 'media',
                });
                const driveData = response.result;
                // Simple merge: Drive data overwrites local if it exists
                if (Array.isArray(driveData)) {
                    state.items = driveData;
                    localStorage.setItem('memoAppData', JSON.stringify(state.items));
                    render();
                }
                setSyncStatus('Google Driveと同期済み');
            } catch (error) {
                console.error('Error loading from Drive:', error);
                setSyncStatus('Driveからの読込に失敗');
            }
        };

        // --- UI Rendering ---
        const render = () => {
            if (state.currentView === 'home') {
                homeView.classList.remove('hidden');
                editorView.classList.add('hidden');
                renderItemsList();
                updateBreadcrumb();
            } else {
                homeView.classList.add('hidden');
                editorView.classList.remove('hidden');
                renderEditor();
            }
        };
        
        const renderItemsList = () => {
            itemsList.innerHTML = '';
            
            const filteredItems = state.items.filter(item => item.parentId === state.currentParentId);
            
            if (filteredItems.length === 0) {
                emptyState.classList.remove('hidden');
            } else {
                emptyState.classList.add('hidden');
            }

            // Sorting logic
            const sortedItems = [...filteredItems].sort((a, b) => {
                // Pinned items always come first
                if (a.isPinned && !b.isPinned) return -1;
                if (!a.isPinned && b.isPinned) return 1;

                const [key, order] = state.sortBy.split('_');
                const valA = a[key];
                const valB = b[key];

                if (valA < valB) return order === 'asc' ? -1 : 1;
                if (valA > valB) return order === 'asc' ? 1 : -1;
                return 0;
            });

            sortedItems.forEach(item => {
                const itemEl = document.createElement('div');
                itemEl.className = 'bg-white p-4 rounded-lg shadow-sm border border-slate-200 hover:shadow-md hover:border-blue-400 transition-all duration-200 cursor-pointer relative group';
                itemEl.dataset.id = item.id;

                const isFolder = item.type === 'folder';
                const icon = isFolder 
                    ? `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-folder mb-2 text-yellow-500"><path d="M4 20h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.93a2 2 0 0 1-1.66-.9l-.82-1.2A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2Z"/></svg>`
                    : `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-file-text mb-2 text-blue-500"><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/><path d="M10 9H8"/><path d="M16 13H8"/><path d="M16 17H8"/></svg>`;
                
                const pinIconColor = item.isPinned ? 'text-yellow-400' : 'text-slate-400 group-hover:text-slate-600';

                itemEl.innerHTML = `
                    ${icon}
                    <h3 class="font-semibold truncate text-slate-800">${item.title || '無題'}</h3>
                    <p class="text-xs text-slate-500 mt-1">${new Date(item.createdAt).toLocaleString('ja-JP')}</p>
                    <div class="absolute top-2 right-2 flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
                        <button class="pin-btn p-1.5 rounded-full hover:bg-slate-200" data-id="${item.id}">
                             <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" class="lucide lucide-pin ${pinIconColor}"><path d="m20.3 5.7-1.1-1.1c-.4-.4-1-.4-1.4 0L12 10.3V3c0-.6-.4-1-1-1s-1 .4-1 1v7.3L4.8 4.6c-.4-.4-1-.4-1.4 0l-1.1 1.1c-.4.4-.4 1 0 1.4l6.7 6.7c.4.4 1 .4 1.4 0l1.1-1.1L18 19v2c0 .6.4 1 1 1s1-.4 1-1v-2l2.3-6.7c.2-.6 0-1.2-.5-1.6z"/></svg>
                        </button>
                        <button class="delete-btn p-1.5 rounded-full hover:bg-red-100" data-id="${item.id}">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-trash-2 text-slate-400 hover:text-red-500"><path d="M3 6h18"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></svg>
                        </button>
                    </div>
                `;

                itemEl.addEventListener('click', (e) => {
                    if (e.target.closest('.delete-btn') || e.target.closest('.pin-btn')) return;
                    handleItemClick(item.id);
                });
                
                itemsList.appendChild(itemEl);
            });
        };

        const renderEditor = () => {
            const item = state.items.find(i => i.id === state.editingItemId);
            if (item) {
                noteTitleInput.value = item.title;
                editor.innerHTML = item.content || '';
            }
        };

        const updateBreadcrumb = () => {
            let path = [{ id: null, title: 'ホーム' }];
            let currentId = state.currentParentId;
            while (currentId) {
                const parent = state.items.find(item => item.id === currentId);
                if (parent) {
                    path.unshift({ id: parent.id, title: parent.title });
                    currentId = parent.parentId;
                } else {
                    break;
                }
            }

            breadcrumb.innerHTML = path.map((p, index) => {
                if (index === path.length - 1) {
                    return `<span class="font-bold text-slate-800">${p.title}</span>`;
                }
                return `<a href="#" class="hover:underline text-blue-600" data-id="${p.id}">${p.title}</a>`;
            }).join('<span class="mx-2 text-slate-400">/</span>');
        };

        // --- Event Handlers ---
        const handleItemClick = (id) => {
            const item = state.items.find(i => i.id === id);
            if (!item) return;

            if (item.type === 'folder') {
                state.currentParentId = id;
            } else {
                state.editingItemId = id;
                state.currentView = 'editor';
            }
            render();
        };

        const createItem = (type) => {
            const title = type === 'folder' ? '新しいフォルダ' : '無題のメモ';
            const newItem = {
                id: generateUUID(),
                type: type,
                title: title,
                content: '',
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString(),
                isPinned: false,
                parentId: state.currentParentId,
            };
            state.items.push(newItem);
            saveData();
            
            if (type === 'note') {
                state.editingItemId = newItem.id;
                state.currentView = 'editor';
            }
            render();
        };
        
        const updateNote = () => {
            const item = state.items.find(i => i.id === state.editingItemId);
            if (item) {
                item.title = noteTitleInput.value;
                item.content = editor.innerHTML;
                item.updatedAt = new Date().toISOString();
                
                // Debounce saving
                clearTimeout(saveTimeout);
                setSyncStatus('変更あり');
                saveTimeout = setTimeout(() => {
                    saveData();
                }, 1000);
            }
        };
        
        const setSyncStatus = (text) => {
            syncStatus.textContent = text;
        };

        const showModal = (modal) => {
            modal.classList.remove('hidden');
            modal.querySelector('div').classList.add('modal-enter-active');
            modal.querySelector('div').classList.remove('modal-enter');
        };

        const hideModal = (modal) => {
            const content = modal.querySelector('div');
            content.classList.add('modal-exit-active');
            content.classList.remove('modal-enter-active');
            setTimeout(() => {
                modal.classList.add('hidden');
                content.classList.remove('modal-exit-active');
            }, 300);
        };

        // --- Event Listeners ---
        createBtn.addEventListener('click', () => showModal(createModal));
        cancelCreateBtn.addEventListener('click', () => hideModal(createModal));
        createNoteBtn.addEventListener('click', () => {
            hideModal(createModal);
            createItem('note');
        });
        createFolderBtn.addEventListener('click', () => {
            hideModal(createModal);
            createItem('folder');
        });

        backToHomeBtn.addEventListener('click', () => {
            state.currentView = 'home';
            state.editingItemId = null;
            render();
        });

        noteTitleInput.addEventListener('input', updateNote);
        editor.addEventListener('input', updateNote);

        sortSelect.addEventListener('change', (e) => {
            state.sortBy = e.target.value;
            render();
        });

        document.querySelectorAll('.editor-tool-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.execCommand(btn.dataset.command, false, null);
                editor.focus();
                updateNote();
            });
        });

        breadcrumb.addEventListener('click', (e) => {
            if (e.target.tagName === 'A') {
                e.preventDefault();
                const id = e.target.dataset.id;
                state.currentParentId = id === 'null' ? null : id;
                render();
            }
        });

        itemsList.addEventListener('click', (e) => {
            const pinBtn = e.target.closest('.pin-btn');
            if (pinBtn) {
                const id = pinBtn.dataset.id;
                const item = state.items.find(i => i.id === id);
                if (item) {
                    item.isPinned = !item.isPinned;
                    saveData();
                    render();
                }
            }

            const deleteBtn = e.target.closest('.delete-btn');
            if (deleteBtn) {
                state.deleteCandidateId = deleteBtn.dataset.id;
                showModal(deleteModal);
            }
        });

        cancelDeleteBtn.addEventListener('click', () => {
            hideModal(deleteModal);
            state.deleteCandidateId = null;
        });

        confirmDeleteBtn.addEventListener('click', () => {
            if (state.deleteCandidateId) {
                // Recursively delete folder contents
                const deleteIds = [state.deleteCandidateId];
                const findChildren = (parentId) => {
                    state.items.forEach(item => {
                        if (item.parentId === parentId) {
                            deleteIds.push(item.id);
                            if (item.type === 'folder') {
                                findChildren(item.id);
                            }
                        }
                    });
                };
                findChildren(state.deleteCandidateId);
                
                state.items = state.items.filter(item => !deleteIds.includes(item.id));
                saveData();
                render();
            }
            hideModal(deleteModal);
            state.deleteCandidateId = null;
        });
        
        // Google Auth Listeners
        authorizeButton.addEventListener('click', handleAuthClick);
        signoutButton.addEventListener('click', handleSignoutClick);


        // --- Initialization ---
        const init = () => {
            // Load from local storage first to render the UI immediately
            const localData = localStorage.getItem('memoAppData');
            if (localData) {
                try {
                    state.items = JSON.parse(localData);
                } catch (e) {
                    console.error("Error parsing local data:", e);
                    state.items = []; // Reset if data is corrupt
                }
            }
            render(); // Render whatever we have locally

            // Load Google API scripts dynamically
            const gapiScript = document.createElement('script');
            gapiScript.src = 'https://apis.google.com/js/api.js';
            gapiScript.onload = gapiLoaded;
            document.body.appendChild(gapiScript);

            const gsiScript = document.createElement('script');
            gsiScript.src = 'https://accounts.google.com/gsi/client';
            gsiScript.onload = gisLoaded;
            document.body.appendChild(gsiScript);
        };

        init();
    });
    </script>
</body>
</html>
